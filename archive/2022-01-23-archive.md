# Archive

## MEMORY ADDRESSES FOR STUFF

/*
    Setup interfaces for filesystem, memory, networking, etc
*/
// static struct MemmapEntry {
// 	hwaddr base;
// 	hwaddr size;
//     virt_memmap[] = {
// 	[VIRT_DEBUG] =       {        0x0,         0x100 },
// 	[VIRT_MROM] =        {     0x1000,       0x11000 },
// 	[VIRT_TEST] =        {   0x100000,        0x1000 },
// 	[VIRT_CLINT] =       {  0x2000000,       0x10000 },
// 	[VIRT_PLIC] =        {  0xc000000,     0x4000000 },
// 	[VIRT_UART0] =       { 0x10000000,         0x100 },
// 	[VIRT_VIRTIO] =      { 0x10001000,        0x1000 },
// 	[VIRT_DRAM] =        { 0x80000000,           0x0 },
// 	[VIRT_PCIE_MMIO] =   { 0x40000000,    0x40000000 },
// 	[VIRT_PCIE_PIO] =    { 0x03000000,    0x00010000 },
// 	[VIRT_PCIE_ECAM] =   { 0x30000000,    0x10000000 },
//     };
// }

## Read stuff
Idea (Updated Jan 23rd)
- Make a rust based binary program that runs on bare metal. I.e. no_std
- has all the modules including drivers and etc
- memory management not really cause theres already stuff for it and we want to support both riscv and arm

The stuff in kernel/arch should be using the high level crate:: stuff and not the other way around. Maybe.

# Update
- Has to build, then run with cfg(feature = "arctest") im pretty sure. Thats how `cargo test` works. I dont think it runs `main()` though rather it runs its own `test_main()` which then runs each test sequentially.

# Interfaces
DriverManager should use a backend for a specific ISA and devices or something. Then you just have to specify the cfg for the drivers when `cargo build` rather then change the non arch dependent code.
